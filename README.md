# GO设计模式

## 创建模式

- [工厂方法模式 Factory Method](https://github.com/a330202207/go-design-pattern/blob/main/factorymethod.go)
    - 工厂方法的优点就在于避免了创建者和具体产品之间的紧密耦合，从而使得代码更容易维护
  
- [抽象工厂模式 Abstract Factory](https://github.com/a330202207/go-design-pattern/blob/main/abstractfactory.go)
    - 抽象工厂模式基于工厂方法模式
    - 两者的区别在于：工厂方法模式是创建出一种产品，而抽象工厂模式是创建出一类产品。这二种都属于工厂模式，在设计上是相似的
    - 假设，有一个存储工厂，提供redis和mysql两种存储数据的方式。如果使用工厂方法模式，我们就需要一个存储工厂，并提供SaveRedis方法和SaveMysql方法
    - 如果此时业务还需要分成存储散文和古诗两种载体，这两种载体都可以进行redis和mysql存储
    - 就可以使用抽象工厂模式，我们需要一个存储工厂作为父工厂，散文工厂和古诗工厂作为子工厂，并提供SaveRedis方法和SaveMysql方法

- [建造者模式 Builder](https://github.com/a330202207/go-design-pattern/blob/main/builder.go)
    - 假设业务需要按步骤创建一系列复杂的对象，实现这些步骤的代码加在一起非常繁复，我们可以将这些代码放进一个包含了众多参数的构造函数中，但这个构造函数看起来将会非常杂乱无章，且难以维护
    - 假设业务需要建造一个房子对象，需要先打地基、建墙、建屋顶、建花园、放置家具……。我们需要非常多的步骤，并且这些步骤之间是有联系的，即使将各个步骤从一个大的构造函数抽出到其他小函数中，整个程序的层次结构看起来依然很复杂
    - 如何解决呢？像这种复杂的有许多步骤的构造函数，就可以用建造者模式来设计
    - 建造者模式的用处就在于能够分步骤创建复杂对象
    - 在建造者模式中，我们需要清晰的定义每个步骤的代码，然后在一个构造函数中操作这些步骤，我们需要一个主管类，用这个主管类来管理各步骤。
    - 这样我们就只需要将所需参数传给一个构造函数，构造函数再将参数传递给对应的主管类，最后由主管类完成后续所有建造任务

- [原型模式 Prototype](https://github.com/a330202207/go-design-pattern/blob/main/prototype.go)
    - 如果你希望生成一个对象，其与另一个对象完全相同，该如何实现呢
    - 如果遍历对象的所有成员，将其依次复制到新对象中，会稍显麻烦，而且有些对象可能会有私有成员变量遗漏
    - 原型模式将这个克隆的过程委派给了被克隆的实际对象，被克隆的对象就叫做"原型"
    - 如果需要克隆一个新的对象，这个对象完全独立于它的原型，那么就可以使用原型模式

- [单例模式 Singleton](https://github.com/a330202207/go-design-pattern/blob/main/singleton.go)
    - 存储着重要对象的全局变量，往往意味着"不安全"，因为你无法保证这个全局变量的值不会在项目的某个引用处被覆盖掉
    - 对数据的修改经常导致出乎意料的的结果和难以发现的bug。我在一处更新数据，却没有意识到软件中的另一处期望着完全不同的数据，于是一个功能就失效了，而且找出故障的原因也会非常困难
    - 一个较好的解决方案是：将这样的"可变数据"封装起来，写一个查询方法专门用来获取这些值
    - 单例模式则更进一步：除了要为"可变数据"提供一个全局访问方法，它还要保证获取到的只有同一个实例。
    - 也就是说，如果你打算用一个构造函数创建一个对象，单例模式将保证你得到的不是一个新的对象，而是之前创建过的对象，并且每次它所返回的都只有这同一个对象，也就是单例。这可以保护该对象实例不被篡改
    - 单例模式需要一个全局构造函数，这个构造函数会返回一个私有的对象，无论何时调用，它总是返回相同的对象

## 结构型模式

- [适配器模式 Adapter](https://github.com/a330202207/go-design-pattern/blob/main/adapter.go)
    - 适配器模式说白了就是兼容
    - 假设一开始我们提供了A对象，后期随着业务迭代，又需要从A对象的基础之上衍生出不同的需求。如果有很多函数已经在线上调用了A对象，此时再对A对象进行修改就比较麻烦，因为需要考虑兼容问题。
    - 还有更糟糕的情况，你可能没有程序库的源代码，从而无法对其进行修改
    - 此时就可以用一个适配器，它就像一个接口转换器，调用方只需要调用这个适配器接口，而不需要关注其背后的实现，由适配器接口封装复杂的过程
    - 假设有2个接口，一个将厘米转为米，一个将米转为厘米。我们提供一个适配器接口，使调用方不需要再操心调用哪个接口，直接由适配器做好兼容

- [桥接模式 Bridge](https://github.com/a330202207/go-design-pattern/blob/main/bridge.go)
    - 假设一开始业务需要两种发送信息的渠道，sms和email，我们可以分别实现sms和email两个接口
    - 之后随着业务迭代，又产生了新的需求，需要提供两种系统发送方式，systemA和systemB，并且这两种系统发送方式都应该支持sms和email渠道
    - 此时至少需要提供4种方法：systemA to sms，systemA to email，systemB to sms，systemB to email
    - 如果再分别增加一种渠道和一种系统发送方式，就需要提供9种方法。这将导致代码的复杂程度指数增长
    - 之前我们是在用继承的想法来看问题，桥接模式则希望将继承关系转变为关联关系，使两个类独立存在
        - 桥接模式需要将抽象和实现区分开
        - 桥接模式需要将"渠道"和"系统发送方式"这两种类别区分开
        - 最后在"系统发送方式"的类里调用"渠道"的抽象接口，使他们从继承关系转变为关联关系

- [对象树模式 Object Tree](https://github.com/a330202207/go-design-pattern/blob/main/objectTree.go)
    - 在项目中，如果我们需要用到树状结构，就可以使用对象树模式。换言之，如果项目的核心模型不能以树状结构表示，则没必要使用对象树模式
    - 对象树模式的用处就在于可以利用多态和递归机制更方便地使用复杂树结构

- [装饰模式 Decorator](https://github.com/a330202207/go-design-pattern/blob/main/decorator.go)
    - 有时候我们需要在一个类的基础上扩展另一个类，例如，一个披萨类，你可以在披萨类的基础上增加番茄披萨类和芝士披萨类
    - 此时就可以使用装饰模式，简单来说，装饰模式就是将对象封装到另一个对象中，用以为原对象绑定新的行为
    - 如果你希望在无需修改代码的情况下使用对象，并且希望为对象新增额外的行为，就可以考虑使用装饰模式

- [外观模式 Facade](https://github.com/a330202207/go-design-pattern/blob/main/facade.go)
    - 如果你需要初始化大量复杂的库或框架，就需要管理其依赖关系并且按正确的顺序执行。此时就可以用一个外观类来统一处理这些依赖关系，以对其进行整合
    - 外观模式和建造者模式很相似。两者的区别在于，外观模式是一种结构型模式，她的目的是将对象组合起来，而不是像建造者模式那样创建出不同的产品

- [享元模式 Flyweight](https://github.com/a330202207/go-design-pattern/blob/main/flyweight.go)
    - 在一些情况下，程序没有足够的内存容量支持存储大量对象，或者大量的对象存储着重复的状态，此时就会造成内存资源的浪费
    - 享元模式提出了这样的解决方案：如果多个对象中相同的状态可以共用，就能在在有限的内存容量中载入更多对象
    - 享元模式希望抽取出能在多个对象间共享的重复状态

- [代理模式 Proxy](https://github.com/a330202207/go-design-pattern/blob/main/proxy.go)
    - 如果你需要在访问一个对象时，有一个像"代理"一样的角色，她可以在访问对象之前为你进行缓存检查、权限判断等访问控制，在访问对象之后为你进行结果缓存、日志记录等结果处理，那么就可以考虑使用代理模式
    - 回忆一下一些web框架的router模块，当客户端访问一个接口时，在最终执行对应的接口之前，router模块会执行一些事前操作，进行权限判断等操作，在执行之后还会记录日志，这就是典型的代理模式
    - 代理模式需要一个代理类，其包含执行真实对象所需的成员变量，并由代理类管理整个生命周期

## 行为型模式

- [责任链模式 Chain of Responsibility](https://github.com/a330202207/go-design-pattern/blob/main/chainofresponsibility.go)
    - 假设我们要让程序按照指定的步骤执行，并且这个步骤的顺序不是固定的，而是可以根据不同需求改变的，每个步骤都会对请求进行一些处理
    - 并将结果传递给下一个步骤的处理者，就像一条流水线一样，我们该如何实现？
    - 当遇到这种必须按顺序执行多个处理者，并且处理者的顺序可以改变的需求，我们可以考虑使用责任链模式

- [命令模式 Command](https://github.com/a330202207/go-design-pattern/blob/main/command.go)
    - 假设你实现了开启和关闭电视机的功能，随着业务迭代，还需要实现开启和关闭冰箱的功能，开启和关闭电灯的功能，开启和关闭微波炉的功能……这些功能都基于你的基类，开启和关闭
    - 如果你之后对基类进行修改，很可能会影响到其他功能，这使项目变得不稳定了
    - 命令模式让命令和对应功能解耦，并能根据不同的请求将其方法参数化

- [迭代器模式 Iterator](https://github.com/a330202207/go-design-pattern/blob/main/iterator.go)
    - 迭代器模式用于遍历集合中的元素，无论集合的数据结构是怎样的

- [中介者模式 Mediator](https://github.com/a330202207/go-design-pattern/blob/main/mediator.go)
    - 中介者模式试图解决网状关系的复杂关联，降低对象间的耦合度
    - 举个例子，假设一个十字路口上的车都是对象，它们会执行不同的操作，前往不同的目的地，那么在十字路口指挥的交警就是“中介者”
    - 各个对象通过执行中介者接口，再由中介者维护对象之间的联系。这能使对象变得更独立，比较适合用在一些对象是网状关系的案例上

- [备忘录模式 Memento](https://github.com/a330202207/go-design-pattern/blob/main/memento.go)
    - 常用的文字编辑器都支持保存和恢复一段文字的操作，如果我们想要在程序中实现保存和恢复的功能该怎么做呢？
    - 我们需要提供保存和恢复的功能，当保存功能被调用时，就会生成当前对象的快照
    - 在恢复功能被调用时，就会用之前保存的快照覆盖当前的快照。这可以使用备忘录模式来做

- [观察者模式 Observer](https://github.com/a330202207/go-design-pattern/blob/main/Observer.go)
    - 如果你需要在一个对象的状态被改变时，其他对象能作为其“观察者”而被通知，就可以使用观察者模式
    - 我们将自身的状态改变就会通知给其他对象的对象称为“发布者”，关注发布者状态变化的对象则称为“订阅者”

- [状态模式 State](https://github.com/a330202207/go-design-pattern/blob/main/state.go)
    - 如果一个对象的实现方法会根据自身的状态而改变，就可以使用状态模式
  
- [策略模式 Strategy](https://github.com/a330202207/go-design-pattern/blob/main/strategy.go)
  - 假设需要实现一组出行的功能，出现的方案可以选择步行、骑行、开车，最简单的做法就是分别实现这3种方法供客户端调用
  - 但这样做就使对象与其代码实现变得耦合了，客户端需要决定出行方式，然后决定调用步行出行、骑行出行、开车出行等方法，这不符合开闭原则
  - 而策略模式的区别在于，它会将这些出行方案抽取到一组被称为策略的类中，客户端还是调用同一个出行对象，不需要关注实现细节，只需要在参数中指定所需的策略即可
  
- [模板方法模式 Template Method](https://github.com/a330202207/go-design-pattern/blob/main/templatemethod.go)
  - 模板方法模式就是将算法分解为一系列步骤，然后在一个模版方法中依次调用这些步骤。这样客户端就不需要了解各个步骤的实现细节，只需要调用模版即可

- [访问者模式 Visitor](https://github.com/a330202207/go-design-pattern/blob/main/visitor.go)
    - 访问者模式试图解决这样一个问题：在不改变类的对象结构的前提下增加新的操作